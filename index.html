<html>
<head>
<title>CS 3300 - Project 1</title>
<link href="https://fonts.googleapis.com/css?family=Raleway:600" rel="stylesheet">
<link rel="stylesheet" href="style.css">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="http://d3js.org/topojson.v2.min.js"></script>
</head>
<body>

<h1 id="title">Search Interest of Fashion Brands in the United States</h1>

<script>

var gridMap;
var gridDict = {};
var popDict = {};
var popScale;

// The visualization is oriented as a circle
var visualizationCenter = [660, 650];
var visualizationRadius = 450;

// Define the brands, their data files, and their representation color
var brands = [["Carhartt", "carhartt.csv", "#e55f00",
               "carhartt-white.png", "carhartt.png"],
              ["RalphLauren", "ralph-lauren.csv", 
                "#3C732E",
               "ralph-lauren-white.png", 
               "ralph-lauren.png"],
              ["VineyardVines", "vineyard-vines.csv", "#046380",
               "vineyard-vines-white.png", "vineyard-vines.png"],
              ["Levi's", "levis.csv", "#1747B0",
               "levis-white.png", "levis.png"],
              ["H&M", "hm.csv", "#E92D00",
               "hm-white.png", "hm.png"],
              ["Topshop", "topshop.csv", "#730046",
               "topshop-white.png", "topshop.png"],
              ["Lululemon", "lulu.csv", "#FF364D",
               "lululemon-white.png", "lululemon.png"]];

// Declare CSV parsing functions for later
function parseBrandRow(row) {
    return { state: row["Region"], value: Number(row["SearchInterest"]) };
}

function parseCompareRow(row) {
    return { brand: row["Brand"], value: Number(row["SearchInterest"]) };
}

function parseGridRow(row) {
    return { x: Number(row["x"]),
             y: Number(row["y"]),
             abbrev: row["key"],
             name: row["name"] };
}

// Gridmap data used from: https://github.com/kristw/gridmap-layout-usa
// (with MIT license)
d3.queue()
.defer(d3.csv, "population.csv", function(row) {
    return { stateName: row["Name"], population: Number(row["2017 Population"])};
})
.defer(d3.csv, "gridmap-layout-usa.csv", parseGridRow)
.await( function (error, popData, gridMapData) {
    gridMap = gridMapData;
    gridMap.forEach(function (d) {
        gridDict[d.name] = d;
    });

    popData.forEach(function (d) {
        popDict[d.stateName] = d.population;
    });
    popExtent = d3.extent(popData, function(d) { return d.population} );
    popScale = d3.scaleLog().domain(popExtent).range([0.4, 1.0]);

    // Prepare to position brand graphs in equidistant locations around a circle
    var degInc = 360.0/(brands.length);
    var degCntr = 20;

    brands.forEach(function (d) {
        // Calculate Polar Coordinates for each graph, then convert to Cartesian
        var x = visualizationCenter[0] +
                (visualizationRadius * Math.cos((Math.PI / 180) * degCntr));
        var y = visualizationCenter[1] +
                (visualizationRadius * Math.sin((Math.PI / 180) * degCntr));
        createMap(x, y, d[0], d[1], d[2], d[4]);

        degCntr += degInc;
    });

    createBrandCluster(visualizationCenter[0], visualizationCenter[1], "all-brands.csv");
});

function createBrandCluster(x, y, csv) {
    // Store width and height for convenience later
    var width = 500;
    var height = 500;

    // Generate a new SVG element and position it as specified
    var svg = d3.select("body").append("svg").attr("height", height).attr("width", width)
    .attr("style", "position: absolute;" + 
                   "top: " + (y - height/2) + ";" + 
                   "left: " + (x - width/2) + ";");

    d3.csv(csv, parseCompareRow, function(error, compareData) {
        var dataDict = {}
        compareData.forEach(function (d) {
            dataDict[d.brand] = d.value;
        });

        var searchExtent = d3.extent(compareData, function(d) { return d.value; });
        var scaleRange = [50,90];
        var searchScale = d3.scaleLinear().domain(searchExtent).range(scaleRange);

        var pack = d3.pack()
        .size([svg.attr("width"), svg.attr("height")])
        .radius(function(d) { return searchScale(dataDict[d.id]); })
        .padding(3);

        // Pack is heirarchy and thus needs a root node, so we append one
        compareData.push({brand: "root"})
        var stratify = d3.stratify()
        .id(function(d) { return d.brand; })
        .parentId(function(d) { 
            if (d.brand == "root")
                return null;
            else
                return "root";
        });

        var root = stratify(compareData);
        pack(root);

        var brandNodes = root.descendants();
        brandNodes.shift();

        var brandCircs = svg.append("g")
        .attr("transform", "translate(0,0)")
        .selectAll(".bubble")
        .data(brandNodes)
        .enter();

        // Don't show the parent circle (root)
        if (function(d) { return d.depth != 0; }) {
            brandCircs.append("circle")
            .attr("cx", function(d){ return d.x; })
            .attr("cy", function(d){ return d.y; })
            .attr("r", function(d){ return d.r; })
            .style("fill", function(d) {
                for (i = 0; i < brands.length; i++) {
                    if (brands[i][0] == d.id)
                        return brands[i][2];
                }

                return "#999999";
            });
            // .attr("opacity", function(d) { return opacityScale(dataDict[d.id]) });

            brandCircs.append("image")
            .attr("x", function(d){ return d.x; })
            .attr("y", function(d){ return d.y; })
            .attr("width", function(d){ return d.r*2 - 20; } )
            .attr("height", function(d){ return d.r*2 - 20; } )
            .attr("href",  function(d) {
                for (i = 0; i < brands.length; i++) {
                    if (brands[i][0] == d.id)
                        return brands[i][3];
                }

                return "";
            })
            .attr("style", "transform: translate(-50%, -50%)");
        }
    });
}

function createMap(x, y, brandName, brandCSVFile, color, brandPicture) {
   
    // Store width and height for convenience later
    var width = 450;
    var height = 300;

    // Generate a new SVG element and position it as specified
    var svg = d3.select("body").append("svg").attr("height", height).attr("width", width)
    .attr("style", "position: absolute;" + 
                   "top: " + (y - height/2) + ";" + 
                   "left: " + (x - width/2) + ";");

    d3.csv(brandCSVFile, parseBrandRow, function(error, brandData) {
        // Make data easily accessible later as a dict (state name -> value)
        var dataDict = {}
        brandData.forEach(function (d) {
            dataDict[d.state] = d.value;
        });

        // Scale up the grid coordinates from the CSV to fit the SVG
        var xExtent = d3.extent(gridMap,
            function(d) { return d.x; });
        var xScale = d3.scaleLinear()
        .domain(xExtent)
        .range([80, width - 80])

        var yExtent = d3.extent(gridMap,
            function(d) { return d.y; });
        var yScale = d3.scaleLinear()
        .domain(yExtent)
        .range([80, height - 80]);

        // Scale the values for each state - scaling is performed on both
        // size and color (opacity)
        var searchExtent = d3.extent(brandData,
            function(d) { return d.value; });
        var searchScale = d3.scaleLinear()
        .domain(searchExtent)
        .range([13, svg.attr("width")/(xExtent[1] - xExtent[0] + 6)]);

        // Draw the brand title
        svg.append("image")
        .attr("x", svg.attr("width")/2)
        .attr("id", brandName)
        .attr("y", 50)
        .attr("width", 100)
        .attr("height", 50)
        .attr("href", brandPicture)
        .attr("style", "transform: translate(-50%, -50%)");

        // Iterate and draw data for each state
        gridMap.forEach(function (state) {
            var size = searchScale(dataDict[state.name]);

            // Occasionally some states do not have data - in this case
            // do not attempt to draw (avoid errors)
            if (!isNaN(size)) {
                // Actually draw the data for a state in the form of a circle
                svg.append("circle")
                .attr("cx", xScale(state.x))
                .attr("cy", xScale(state.y))
                .attr("r", size/2)
                .attr("fill", color)
                .attr("opacity", popScale(popDict[state.name]));

                // Label each state appropriately
                svg.append("text")
                .attr("x", xScale(state.x))
                .attr("y", xScale(state.y))
                .attr("font-size", size/3)
                .attr("alignment-baseline", "central")
                .attr("text-anchor", "middle")
                .attr("fill", "#ffffff")
                .attr("font-family", "Raleway")
                .text(state.abbrev);
            } else {
            	// Actually draw the data for a state in the form of a circle
                svg.append("circle")
                .attr("cx", xScale(state.x))
                .attr("cy", xScale(state.y))
                .attr("fill", "#999")
                .attr("r", 8);

                // Label each state appropriately
                svg.append("text")
                .attr("x", xScale(state.x))
                .attr("y", xScale(state.y))
                .attr("font-size", 5)
                .attr("alignment-baseline", "central")
                .attr("text-anchor", "middle")
                .attr("fill", "#ffffff")
                .attr("font-family", "Raleway")
                .text(state.abbrev);
            }
        });
    });
}

</script>
<style>
    #title {
        position: absolute;
        white-space: nowrap;
        top: 5px;
        left: 660px;
        font-family: "Raleway";
        transform: translateX(-50%);
        text-align: center;
    }
    #Topshop {
        width: 150;
        height: 80;
    }
    #RalphLauren {
        width: 150;
        height: 80;
    }
    #VineyardVines {
        width: 150;
        height: 80;
    }
</style>
</body>